# AGENTS.md - NixOS Configuration Repository Guide

This repository contains a personal NixOS system configuration that runs on both native NixOS and Windows WSL environments. The configuration is designed to be portable across machines while maintaining consistency.

## Repository Overview

**Purpose**: Declarative system configuration for NixOS using the Nix expression language  
**User**: `emerald` (hardcoded - do not change)  
**Environments**: Native NixOS with Hyprland (Wayland) and Windows WSL  
**Channel**: NixOS 24.11 (stable)

## Essential Commands

### System Management
```bash
# Rebuild and switch to new configuration (main command)
sudo nixos-rebuild switch

# Test configuration without making it permanent
sudo nixos-rebuild test

# Build configuration without switching
sudo nixos-rebuild build

# Rollback to previous generation
sudo nixos-rebuild switch --rollback
```

### Configuration Sync (Git)
The repository uses custom zsh functions for syncing configurations:

```bash
# Push local changes to remote
nix-push    # or: np

# Pull remote changes
nix-pull    # or: nl

# Pull then push (full sync)
nix-sync    # or: ns

# Check git status of nixos config
nix-status  # or: nst
```

These functions:
- Auto-commit with timestamp and hostname
- Handle adoption of local changes when pulling
- Push to `origin master` branch

### Companion Dotfiles Repository
There's a separate `.dotfiles` repository in `~/.dotfiles` that uses `stow` for symlinking:

```bash
# Dotfiles sync commands (similar pattern)
dot-push    # or: dp
dot-pull    # or: dl
dot-sync    # or: ds
dot-status  # or: dst
```

## Project Structure

### Core Configuration Files

#### `configuration.nix` (Base)
- **Main entry point** - imported by all environments
- Defines core packages, user setup, system version
- Uses conditional imports to load environment-specific configs
- Automatically detects WSL vs native via `/proc/sys/fs/binfmt_misc/WSLInterop`
- Pulls from NixOS unstable channel for certain packages (Go, etc.)
- Imports NUR (Nix User Repository) for community packages like `crush`

**Key features:**
- User `emerald` with UID 1000, groups: wheel, video, audio, input, docker
- Allows unfree packages (`nixpkgs.config.allowUnfree = true`)
- Experimental features enabled: `nix-command`, `flakes`
- Docker virtualization enabled
- Dynamic linking enabled via `programs.nix-ld.enable = true` (required for NUR packages)

#### `native-hyperland.nix` (Native Wayland Environment)
- Hyprland (Wayland compositor) setup
- Display manager: SDDM with Wayland
- Desktop environment packages: wofi, waybar, hyprpaper, grim, slurp, mako
- Hardware-specific: Arduino, platformio, brightness controls
- Retrosmart cursor theme (custom package)
- Environment variables for Wayland compatibility
- Grub bootloader with OS prober
- Timezone: America/New_York
- Auto-login for user `emerald`

#### `native.nix` (Legacy Native i3 Environment)
- X11 + i3 window manager setup
- Currently commented out in imports (Hyprland is active)
- Similar structure to native-hyperland but for X11
- Uses flameshot for screenshots (X11-specific)

#### `wsl.nix` (WSL Environment)
- Minimal - just enables WSL and sets default user
- Imports nixos-wsl module from `<nixos-wsl/modules>`

#### `zsh.nix` (Shell Configuration)
- Oh My Zsh with 60+ plugins (extensive list)
- Custom functions for tmux session management
- Repo sync functions (nix-push, dot-push, etc.)
- Auto-starts tmux in interactive shells
- Status checks on shell startup (in default tmux session only)
- History configuration with deduplication
- Sources secrets from `~/.config/secrets/env` (not tracked)
- Adds `~/.bashScripts` to PATH
- Hyprctl wrapper function to handle socket detection

**Custom tmux workflows:**
- `tmux-work` (alias: `tw`) - Creates predefined work session with claude, code, watcher windows
- `tmux-project` (alias: `tp`) - FZF-based project selector from ~/repos with automatic setup

#### `hardware-configuration.nix`
- Auto-generated by NixOS
- **Do NOT manually edit** - regenerated on hardware changes
- Contains kernel modules, filesystem UUIDs, boot parameters

#### `postgres.nix`
- PostgreSQL service configuration
- Pre-configured databases: `prism`, `pact`
- Authentication: local trust (development setup)

#### `retrosmart-cursors.nix`
- Custom Nix derivation for cursor theme
- Fetches from GitHub (mdomlop/retrosmart-x11-cursors v3.1a)
- Build dependencies: imagemagick, xcursorgen
- Used only in native-hyperland.nix

## Key Patterns & Conventions

### Nix Expression Style
- Use `let...in` blocks for importing additional channels or defining local packages
- Attribute sets use semicolon separators: `{ foo = "bar"; }`
- Comments use `#` for single-line
- Boolean attributes: `enable = true;`
- List syntax: `[ "item1" "item2" ]`
- Package references: `pkgs.package-name` or `with pkgs; [ package1 package2 ]`
- Unstable packages: `unstable.package-name` (defined in configuration.nix)

### Configuration Organization
- **One file per environment/concern**: Don't merge wsl.nix and native.nix
- Base configuration in `configuration.nix`, environment-specific in separate files
- Use imports to compose configurations
- Hardware config is separate and auto-generated

### Import Pattern
```nix
imports = if builtins.pathExists "/proc/sys/fs/binfmt_misc/WSLInterop"
  then  [ ./wsl.nix ./zsh.nix <nixos-wsl/modules> ]
  else  [ ./hardware-configuration.nix ./zsh.nix ./native-hyperland.nix ];
```
This auto-detects environment and loads appropriate configs.

### User Configuration
- Username is **always** `emerald` - this is critical for the setup
- Home directory: `/home/emerald`
- Shell: zsh
- Groups: wheel (sudo), video, audio, input, docker, networkmanager, dialout, plugdev

## Important Gotchas

### 1. Username is Sacred
The entire configuration assumes username `emerald`. Dotfiles, paths, scripts all depend on this. Changing it will break things.

### 2. Two-Repository System
- `~/nixos` - This repository (system config)
- `~/.dotfiles` - Separate repository (user dotfiles managed with stow)
- Both repos have sync commands and status checks built into zsh
- Status checks run automatically when opening a new shell in the default tmux session

### 3. WSL vs Native Detection
The configuration auto-detects the environment by checking for `/proc/sys/fs/binfmt_misc/WSLInterop`. Don't override this logic manually - let it detect automatically.

### 4. Rebuild Process
- `sudo nixos-rebuild switch` applies changes immediately
- On failure, system automatically reverts to previous generation
- Always test configuration syntax before rebuilding
- Changes to zsh.nix require a new shell to take effect

### 5. Hyprland Socket Management
The zsh.nix includes a custom `hyprctl` function wrapper that auto-detects the Hyprland instance signature. This is needed because the socket path changes between sessions.

### 6. Channel Mixing
The configuration pulls from multiple sources:
- Stable NixOS 24.11 (main)
- Unstable channel for select packages (Go)
- NUR for community packages (crush)

This is intentional - don't "clean it up" to use only stable.

### 7. Tmux Auto-Start
ZSH automatically starts or attaches to tmux in interactive shells. This is intentional behavior. The status checks only run in the "default" session to avoid spam.

### 8. Secrets Management
API keys and secrets should go in `~/.config/secrets/env` which is sourced by zsh but NOT tracked in git. Never commit secrets to nixos or dotfiles repos.

### 9. Windows Integration (WSL)
- win32yank is aliased for clipboard integration with Windows
- Windows paths added to PATH: `/mnt/c/Windows/System32`, `/mnt/c/Windows`

### 10. Hardware-Configuration.nix
This file is generated by the installer. If you need to reinstall or move hardware:
```bash
sudo nixos-generate-config --show-hardware-config > hardware-configuration.nix
```

## Development Stack

### Languages & Runtimes
- **Go**: From unstable channel (primary language based on commit history)
- **C/C++**: clang, gcc, gdb, clang-tools
- **Zig**: Installed
- **Python 3**: Installed with pip
- **Node.js**: npm included
- **Rust**: cargo installed (for dependencies like htmx-lsp)
- **TinyGo**: For embedded work

### Tools & Infrastructure
- **Editor**: neovim-unwrapped (configured via dotfiles)
- **Terminal multiplexer**: tmux with resurrect, yank, sensible plugins
- **Containers**: Docker with docker-compose
- **Infrastructure**: Terraform, Azure CLI, AWS CLI
- **Databases**: PostgreSQL, SQLite
- **Version control**: Git (configured with user.email and user.name)
- **AI Assistant**: crush (from NUR)

### Build Tools
- protobuf (v28), protoc-gen-go, protoc-gen-go-grpc
- gofumpt (Go formatter)
- stylua (Lua formatter)
- Hugo (static site generator)

### Media & Utilities
- ffmpeg (video processing)
- yt-dlp (video downloading)
- mediamtx (RTMP/streaming)
- jq (JSON processing)
- ripgrep (fast grep)
- fzf (fuzzy finder)
- direnv (directory-specific environments)

## Testing Approach

### Pre-Deployment Testing
Before running `sudo nixos-rebuild switch`:

1. **Syntax check**: Use `nix-instantiate --parse` to validate syntax
   ```bash
   nix-instantiate --parse configuration.nix
   ```

2. **Build test**: Build without switching
   ```bash
   sudo nixos-rebuild build
   ```

3. **Dry run**: See what would change
   ```bash
   sudo nixos-rebuild dry-build
   ```

### Post-Deployment Verification
After rebuilding:
- Check that new packages are available: `which <package-name>`
- Verify services are running: `systemctl status <service>`
- Test zsh changes: open new shell
- For GUI changes (Hyprland): log out and back in

### Recovery
If system breaks after rebuild:
```bash
# Rollback to previous generation
sudo nixos-rebuild switch --rollback

# List all generations
sudo nix-env --list-generations --profile /nix/var/nix/profiles/system

# Switch to specific generation
sudo nix-env --profile /nix/var/nix/profiles/system --switch-generation <number>
```

## Git Workflow

### Commit Conventions
Looking at git history, commits follow these patterns:
- `sync: <hostname> <time>` - Regular config syncs
- `adopt: <hostname> <time>` - Pulling remote changes with local adoption
- Descriptive commits for features: "doing a bunch with the wallpapers for hyprland, removing bugs."

### Branch Strategy
- Single `master` branch
- No feature branches observed
- Direct commits to master
- Sync happens frequently (multiple times per day based on timestamps)

### Typical Workflow
```bash
# Make configuration changes
vim ~/nixos/configuration.nix

# Test the configuration
sudo nixos-rebuild test

# If good, switch to it
sudo nixos-rebuild switch

# Push to GitHub
nix-push
# or manually:
cd ~/nixos
git add .
git commit -m "descriptive message"
git push origin master
```

## Machine Setup (New Installation)

From the README.md, here's the bootstrap process:

1. Install NixOS (either native or WSL)
2. Create user named `emerald` during installation (critical!)
3. Install git: `nix-shell -p git`
4. Set up SSH authentication for GitHub
5. Clone repositories:
   ```bash
   cd ~
   git clone git@github.com:JeffMuter/nixos.git nixos
   git clone git@github.com:JeffMuter/.dotfiles.git .dotfiles
   ```
6. Run initial rebuild:
   ```bash
   cd ~/nixos
   sudo nixos-rebuild switch
   ```
7. The system will configure itself based on environment detection

## Additional Context

### Projects Referenced
Based on zsh.nix, the user works on:
- `cloudinaryFileSync` - Main project with watcher, templates, multiple components
- Blog at `saorsadev-blog` (Hugo-based)
- Various repos in `~/repos/` directory

### Tmux Workflow
The zsh configuration shows heavy tmux usage:
- Default session for daily work
- Work session (`tw`) for cloudinaryFileSync project
- Project selector (`tp`) for quick navigation
- Windows named: claude, code, terminal, watcher, db
- Auto-starts `nix-shell` and `claude` in project sessions
- DBUI integration in database window

### Terminal Environment
- Primary terminal (WSL): Likely Windows Terminal
- Primary terminal (native): ghostty (Wayland) or alacritty
- Clipboard: xclip, xsel (X11), wl-clipboard (Wayland)
- Notifications (native): mako
- Screenshot (native): grim + slurp (Wayland)
- App launcher (native): wofi

### Shell Features
Massive Oh My Zsh plugin list includes:
- Git integration (multiple plugins)
- Cloud providers: aws, gcloud, azure
- Container tools: docker, kubectl, helm
- Languages: go, python, rust, node
- Utilities: fzf, z (jump), thefuck, direnv

The `thefuck` tool is installed - it corrects previous console commands.

## Nix-Specific Notes

### Package Management
```bash
# Search for packages
nix search nixpkgs <package-name>

# Run a package without installing
nix-shell -p <package-name>

# Upgrade all packages
sudo nixos-rebuild switch --upgrade

# Garbage collect old generations
sudo nix-collect-garbage -d
```

### Flakes
Experimental flakes are enabled but not currently used in this configuration. The setup uses traditional channel-based configuration.

### NUR (Nix User Repository)
The configuration imports NUR for community packages. Currently used for:
- `crush` - AI terminal assistant from charmbracelet

### Unstable Channel
Packages from unstable:
- `go` - Needs latest version for development

## File Permissions & Ownership

- All .nix files should be readable by all users
- Configuration files owned by emerald but read by root during rebuild
- No special permissions needed for declarative configs
- Scripts in `.bashScripts` should be executable (`chmod +x`)

## Summary for AI Agents

**When working in this repository:**

1. **Never change the username** - it's `emerald` everywhere
2. **Test before applying** - Use `sudo nixos-rebuild test` first
3. **Follow the modular structure** - Keep environment-specific configs in their own files
4. **Respect the auto-detection** - Don't hardcode environment paths
5. **Maintain the sync workflow** - Use the custom git functions (np, nl, ns, nst)
6. **Preserve package sources** - Keep the mix of stable/unstable/NUR
7. **Don't edit hardware-configuration.nix** - It's auto-generated
8. **Remember the two-repo system** - nixos (system) + .dotfiles (user)
9. **Check both repos on changes** - Some configs span both repositories
10. **Use tmux patterns** - The workflow heavily depends on tmux

This is a **well-maintained, actively-used** personal configuration with careful attention to portability and consistency across environments.
